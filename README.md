# 알고리즘이란?
- 어떤 목적을 달성하거나 결과물을 만들어내기 위해 거쳐야 하는 일련의 과정들을 의미한다.
- 상황에 따른 알고리즘은 모두 다르다. 따라서 시간복잡도가 가장 낮은 알고리즘을 선택하여 사용한다.

> [!NOTE]  
> 알고리즘의 실행시간은 컴퓨터가 알고리즘 코드를 실행하는 속도에 의존한다.
>
> 이 속도는 컴퓨터의 속도, 사용된 언어종류, 컴파일러의 속도에 달려있다.

# 시간복잡도
시간복잡도는 주어진 문제를 해결하기 위한 연산 횟수를 말한다.

## 시간 복잡도 표현방법
이 속도는 컴퓨터의 속도, 사용된 언어종류, 컴파일러의 속도에 달려있다.

- 최상의 경우: Big-Ω(빅-오메가) = 알고리즘 수행 시간이 가장 적게 걸리는 것
- 보통의 경우: Big-θ(빅-세타) = 알고리즘 수행 시간 확률을 고려한 평균적인 시간
- 최악의 경우: Big-O(빅-오) = 알고리즘 수행 시간이 가장 오래 걸리는 것

## 빅오 표기법(Big-O)
n 개의 자료를 실행할 때 걸리는 시간함수를 `시간 복잡도 함수` 라고 한다.

`시간 복잡도 함수`를 통해 정확한 시간을 알아도 좋지만, 대략적으로 프로그램이 실행되는데 필요한 시간만 알면되기 때문에 빅오 표기법을 사용한다.

> [!NOTE]  
> 빅오 표기법은 불필요한 연산을 제거하여 알고리즘 분석을 쉽게 할 목적으로 사용된다.

### 1. O(1)
입력값(N)이 증가해도 실행시간은 동일한 알고리즘, index로 접근하여 바로 처리할 수 있는 연산과정의 시간 복잡도
> stack 의 push, pop

### 2. O(log N) 
연산이 한 번 실행될 때마다 데이터의 크기가 절반 감소하는 알고리즘
> binary search 알고리즘, tree 형태 자료구조 탐색, 이진트리

### 3. O(N)
입력값(N)이 증가함에 따라 실행시간도 선형적으로 증가하는 알고리즘
> 1중 for 문

### 4. O(N log N)
O(N)의 알고리즘과 O(log N)의 알고리즘이 중첩된 형태
> 퀵 정렬(quick sort), 병합정렬(merge sort), 힙 정렬(heap Sort)

### 5. O(N^2)
O(N)의 알고리즘과 O(log N)의 알고리즘이 중첩된 형태
> 이중 for 문, 삽입정렬(insertion sort), 거품정렬(bubble sort), 선택정렬(selection sort)

### 6. O(2^N)
빅오 표기법 중 가장 느린 시간 복잡도로 주로 재귀적으로 수행하는 알고리즘이 이에 해당
> 피보나치(fibonacci) 수열


> [!TIP]  
> 입력 데이터의 범위와 실행 시간 범위를 고려하면 문제에 대한 감을 잡을 수 있다.
> 보통 1초에 1억 번 연산하는 수행시간은 1초이다. 
> 이를 기준으로 전체 수행시간을 어림잡아 문제에 사용되는 알고리즘에 대한 힌트를 얻으면 알고리즘 사용 가능 여부를 판단하여 접근할 수 있다.
